# Week02 시험

### 1697: 숨바꼭질
* 왜 목적지인 K를 만나면 즉시 종료하면 안 되는가?
* queue에서 먼저 나오는 값은 항상 최적의 시간인가?

### 16290: PPAP
1. 문자를 하나씩 탐색하면서 스택에 넣는다.
2. 스택에 문자가 4개이면 스택의 문자가 'PPAP'인지 검사한다.
  1. 맞으면, 'PPAP'를 'P'로 바꾼다.

3. 마지막 스택에 남은 글자가 'PPAP'이거나 'P'이면 PPAP 문자열이다.
```python
# pseudo
input
stack =[]
PPAP = ['P', 'P', "A", 'P']

for i in input:
  stack.append(i)
  if len(stack) == 4:
    if stack[-4:] ==  PPAP:
      pop all
      stack.append('P')

if stack == 'PPAP' or stack == 'P':
  # ppap 문자열이다
  print('PPAP')
else:
  print('NP')
```

### 1939: 중량제한
* 간선마다 중량의 제한이 있을 때, 출발점에서 도착점으로 가기 위한 중량의 최댓값을 구하시오.
* 경로에서 중량제한이 가장 낮은 간선이 최대가 되도록 하는 경로 -- 여기서 이분탐색의 힌트
* 각 노드들에 대해 노드가 가질 수 있는 최대 중량을 업데이트

<!-- 1. 처음 inf짐을 들고 출발 (짐[start] = inf)
2. 다른 모든 노드의 짐은 0 (짐[i] = 0s)
2. bfs 각 노드 탐색
  1. if 짐[next] < 짐[curr] -->

* 이분 탐색으로 풀 수도 있다.
* k라는 무게가 주어졌을 때
* bfs/dfs를 통해 출발에서 목적지까지 갈 수 있는지 없는지를 이분탐색
* 만약 간선의 중량제한이 k보다 작으면 갈 수 없음


---
### 시험 종료 후 코치님 리뷰
dfs는 스택이고 bfs는 큐/우선순위큐이다.

그래프라는 것은 '관계'를 나타낸 것이다. 때문에 대부분의 문제 상황은 그래프로 나타낼 수 있겠다.

그래프의 중요한 점은 vertex, edge, weight

unoion find와 bfs/dfs의 목적은 다르다. u/f는 정점이 어떤 set(connected component)에 속하는지를 찾는다. dfs/bfs는 정점을 탐색한다.

트리의 순회는 어디에 쓸 수 있을까? 수식의 계산
* 우리는 중위순회로 수식을 쓴다
* 계산은 전위 또는 후위로 된다.

트리의 순회는 그래프에도 통할 수 있다.
* 그래프에서 모든 노드를 만드는 트리를 만들 수 있다.
* 스패닝 트리에서도 전위/중위/후위 순회를 할 수 있다.

스택/큐 - 트리 - 그래프 순으로 연결된다.

